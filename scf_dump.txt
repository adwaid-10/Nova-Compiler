=== Running FuseMatmulBias Pass ===
=== FuseMatmulBias Pass Complete ===
// -----// IR Dump After LowerAffinePass (lower-affine) //----- //
module {
  func.func @main1(%arg0: memref<256x256x256xf32>, %arg1: memref<256x256x256xf32>, %arg2: memref<256x256x256xf32>) -> memref<256x256x256xf32> {
    %cst = arith.constant 0.000000e+00 : f32
    %alloc = memref.alloc() {alignment = 64 : i64} : memref<256x256x256xf32>
    %c0 = arith.constant 0 : index
    %c256 = arith.constant 256 : index
    %c64 = arith.constant 64 : index
    scf.parallel (%arg3) = (%c0) to (%c256) step (%c64) {
      %c0_7 = arith.constant 0 : index
      %c256_8 = arith.constant 256 : index
      %c64_9 = arith.constant 64 : index
      scf.parallel (%arg4) = (%c0_7) to (%c256_8) step (%c64_9) {
        %c0_10 = arith.constant 0 : index
        %c256_11 = arith.constant 256 : index
        %c4 = arith.constant 4 : index
        scf.parallel (%arg5) = (%c0_10) to (%c256_11) step (%c4) {
          %c64_12 = arith.constant 64 : index
          %0 = arith.addi %arg3, %c64_12 : index
          %c1 = arith.constant 1 : index
          scf.parallel (%arg6) = (%arg3) to (%0) step (%c1) {
            %c64_13 = arith.constant 64 : index
            %1 = arith.addi %arg4, %c64_13 : index
            %c1_14 = arith.constant 1 : index
            scf.parallel (%arg7) = (%arg4) to (%1) step (%c1_14) {
              %c4_15 = arith.constant 4 : index
              %2 = arith.addi %arg5, %c4_15 : index
              %c1_16 = arith.constant 1 : index
              scf.parallel (%arg8) = (%arg5) to (%2) step (%c1_16) {
                memref.store %cst, %alloc[%arg6, %arg7, %arg8] : memref<256x256x256xf32>
                scf.reduce 
              }
              scf.reduce 
            }
            scf.reduce 
          }
          scf.reduce 
        }
        scf.reduce 
      }
      scf.reduce 
    }
    %c0_0 = arith.constant 0 : index
    %c256_1 = arith.constant 256 : index
    %c64_2 = arith.constant 64 : index
    scf.parallel (%arg3) = (%c0_0) to (%c256_1) step (%c64_2) {
      %c0_7 = arith.constant 0 : index
      %c256_8 = arith.constant 256 : index
      %c64_9 = arith.constant 64 : index
      scf.parallel (%arg4) = (%c0_7) to (%c256_8) step (%c64_9) {
        %c0_10 = arith.constant 0 : index
        %c256_11 = arith.constant 256 : index
        %c4 = arith.constant 4 : index
        scf.parallel (%arg5) = (%c0_10) to (%c256_11) step (%c4) {
          %c0_12 = arith.constant 0 : index
          %c256_13 = arith.constant 256 : index
          %c4_14 = arith.constant 4 : index
          scf.for %arg6 = %c0_12 to %c256_13 step %c4_14 {
            %c64_15 = arith.constant 64 : index
            %0 = arith.addi %arg3, %c64_15 : index
            %c1 = arith.constant 1 : index
            scf.parallel (%arg7) = (%arg3) to (%0) step (%c1) {
              %c64_16 = arith.constant 64 : index
              %1 = arith.addi %arg4, %c64_16 : index
              %c1_17 = arith.constant 1 : index
              scf.parallel (%arg8) = (%arg4) to (%1) step (%c1_17) {
                %c4_18 = arith.constant 4 : index
                %2 = arith.addi %arg5, %c4_18 : index
                %c1_19 = arith.constant 1 : index
                scf.parallel (%arg9) = (%arg5) to (%2) step (%c1_19) {
                  %c4_20 = arith.constant 4 : index
                  %3 = arith.addi %arg6, %c4_20 : index
                  %c1_21 = arith.constant 1 : index
                  scf.for %arg10 = %arg6 to %3 step %c1_21 {
                    %4 = memref.load %arg0[%arg7, %arg8, %arg10] : memref<256x256x256xf32>
                    %5 = memref.load %arg1[%arg7, %arg10, %arg9] : memref<256x256x256xf32>
                    %6 = memref.load %alloc[%arg7, %arg8, %arg9] : memref<256x256x256xf32>
                    %7 = arith.mulf %4, %5 : f32
                    %8 = arith.addf %7, %6 : f32
                    memref.store %8, %alloc[%arg7, %arg8, %arg9] : memref<256x256x256xf32>
                  }
                  scf.reduce 
                }
                scf.reduce 
              }
              scf.reduce 
            }
          }
          scf.reduce 
        }
        scf.reduce 
      }
      scf.reduce 
    }
    %alloc_3 = memref.alloc() {alignment = 64 : i64} : memref<256x256x256xf32>
    %c0_4 = arith.constant 0 : index
    %c256_5 = arith.constant 256 : index
    %c64_6 = arith.constant 64 : index
    scf.parallel (%arg3) = (%c0_4) to (%c256_5) step (%c64_6) {
      %c0_7 = arith.constant 0 : index
      %c256_8 = arith.constant 256 : index
      %c64_9 = arith.constant 64 : index
      scf.parallel (%arg4) = (%c0_7) to (%c256_8) step (%c64_9) {
        %c0_10 = arith.constant 0 : index
        %c256_11 = arith.constant 256 : index
        %c4 = arith.constant 4 : index
        scf.parallel (%arg5) = (%c0_10) to (%c256_11) step (%c4) {
          %c64_12 = arith.constant 64 : index
          %0 = arith.addi %arg3, %c64_12 : index
          %c1 = arith.constant 1 : index
          scf.parallel (%arg6) = (%arg3) to (%0) step (%c1) {
            %c64_13 = arith.constant 64 : index
            %1 = arith.addi %arg4, %c64_13 : index
            %c1_14 = arith.constant 1 : index
            scf.parallel (%arg7) = (%arg4) to (%1) step (%c1_14) {
              %c4_15 = arith.constant 4 : index
              %2 = arith.addi %arg5, %c4_15 : index
              %c1_16 = arith.constant 1 : index
              scf.parallel (%arg8) = (%arg5) to (%2) step (%c1_16) {
                %3 = memref.load %alloc[%arg6, %arg7, %arg8] : memref<256x256x256xf32>
                %4 = memref.load %arg2[%arg6, %arg7, %arg8] : memref<256x256x256xf32>
                %5 = arith.addf %3, %4 : f32
                memref.store %5, %alloc_3[%arg6, %arg7, %arg8] : memref<256x256x256xf32>
                scf.reduce 
              }
              scf.reduce 
            }
            scf.reduce 
          }
          scf.reduce 
        }
        scf.reduce 
      }
      scf.reduce 
    }
    return %alloc_3 : memref<256x256x256xf32>
  }
}


PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/tools/nova-opt/nova-opt ./test/testR.mlir --nova-gpu-pipeline -mlir-print-ir-after=lower-affine
 #0 0x000071398208b3d2 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/blu-bridge023/Desktop/llvm-project/build/./lib/libLLVM.so.21.1+0xc8b3d2)
 #1 0x0000713982087bbf llvm::sys::RunSignalHandlers() (/home/blu-bridge023/Desktop/llvm-project/build/./lib/libLLVM.so.21.1+0xc87bbf)
 #2 0x0000713982087d0c SignalHandler(int, siginfo_t*, void*) Signals.cpp:0:0
 #3 0x0000713980c42520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)
 #4 0x000056f15471c894 mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::OpOperand*, mlir::ValueRange) (./build/tools/nova-opt/nova-opt+0xa7d894)
 #5 0x000056f15470c198 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (./build/tools/nova-opt/nova-opt+0xa6d198)
 #6 0x000056f15470c6ea mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (./build/tools/nova-opt/nova-opt+0xa6d6ea)
 #7 0x000056f15470ce0e mlir::Operation::create(mlir::OperationState const&) (./build/tools/nova-opt/nova-opt+0xa6de0e)
 #8 0x000056f15466a893 mlir::OpBuilder::create(mlir::OperationState const&) (./build/tools/nova-opt/nova-opt+0x9cb893)
 #9 0x0000713989ec6b75 processParallelLoop(mlir::scf::ParallelOp, mlir::gpu::LaunchOp, mlir::IRMapping&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::DenseMap<mlir::gpu::Processor, mlir::Value, llvm::DenseMapInfo<mlir::gpu::Processor, void>, llvm::detail::DenseMapPair<mlir::gpu::Processor, mlir::Value> >&, mlir::PatternRewriter&) SCFToGPU.cpp:0:0
#10 0x0000713989ec8d09 (anonymous namespace)::ParallelToGpuLaunchLowering::matchAndRewrite(mlir::scf::ParallelOp, mlir::PatternRewriter&) const SCFToGPU.cpp:0:0
#11 0x000056f1548956c9 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (./build/tools/nova-opt/nova-opt+0xbf66c9)
#12 0x000071398db8f6f8 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#13 0x000071398db8fc8c mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/blu-bridge023/Desktop/llvm-project/build/./lib/libMLIR.so.21.1+0x5f8fc8c)
#14 0x000071398db93cd3 mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/blu-bridge023/Desktop/llvm-project/build/./lib/libMLIR.so.21.1+0x5f93cd3)
#15 0x000071398db9547b applyConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig, (anonymous namespace)::OpConversionMode) DialectConversion.cpp:0:0
#16 0x000071398db955c2 mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/blu-bridge023/Desktop/llvm-project/build/./lib/libMLIR.so.21.1+0x5f955c2)
#17 0x0000713989ecb9d0 (anonymous namespace)::ParallelLoopToGpuPass::runOnOperation() SCFToGPUPass.cpp:0:0
#18 0x000056f15479efb6 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (./build/tools/nova-opt/nova-opt+0xafffb6)
#19 0x000056f15479f439 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (./build/tools/nova-opt/nova-opt+0xb00439)
#20 0x000056f1547a0392 mlir::PassManager::run(mlir::Operation*) (./build/tools/nova-opt/nova-opt+0xb01392)
#21 0x000056f154622a60 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#22 0x000056f154623223 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPoolInterface*) MlirOptMain.cpp:0:0
#23 0x000056f15462344c llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#24 0x000056f1546347d2 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (./build/tools/nova-opt/nova-opt+0x9957d2)
#25 0x000056f154619735 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (./build/tools/nova-opt/nova-opt+0x97a735)
#26 0x000056f1546235c3 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (./build/tools/nova-opt/nova-opt+0x9845c3)
#27 0x000056f154623ab8 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (./build/tools/nova-opt/nova-opt+0x984ab8)
#28 0x000056f154591ddc main /home/blu-bridge023/Desktop/NEW/Nova-Compiler/tools/nova-opt/nova-opt.cpp:111:7
#29 0x0000713980c29d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16
#30 0x0000713980c29e40 call_init ./csu/../csu/libc-start.c:128:20
#31 0x0000713980c29e40 __libc_start_main ./csu/../csu/libc-start.c:379:5
#32 0x000056f154591a75 _start (./build/tools/nova-opt/nova-opt+0x8f2a75)
